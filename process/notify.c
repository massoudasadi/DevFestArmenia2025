#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <bpf/libbpf.h>
#include "notify.skel.h" // This header is generated by bpftool

struct event {
    int pid;
    char comm[16];
};

/* CALLBACK: This function runs every time the kernel sends an event. */
static int handle_event(void *ctx, void *data, size_t data_sz) {
    const struct event *e = data;
    // We only get here if the kernel-side filter (is_firefox) passed.
    printf("ALERT: Firefox started! [PID: %d]\n", e->pid);
    return 0;
}

int main() {
    struct notify_bpf *skel;
    struct ring_buffer *rb = NULL;

    /* 1. Open and Load the BPF byte code into the kernel. 
     * This verifies the security of the BPF code. */
    skel = notify_bpf__open_and_load();
    if (!skel) {
        fprintf(stderr, "Failed to open and load BPF skeleton\n");
        return 1;
    }

    /* 2. Attach the BPF program to the tracepoint. */
    notify_bpf__attach(skel);

    /* 3. Set up the ring buffer consumer. 
     * We pass the FD of the map and our callback function. */
    rb = ring_buffer__new(bpf_map__fd(skel->maps.rb), handle_event, NULL, NULL);
    
    printf("Listening for Firefox starts... (Ctrl+C to quit)\n");

    /* 4. Infinite loop to check for new data. 
     * ring_buffer__poll is efficient and doesn't hog the CPU. */
    while (1) {
        ring_buffer__poll(rb, 100 /* timeout in ms */);
    }

    /* Clean up before exit */
    ring_buffer__free(rb);
    notify_bpf__destroy(skel);
    return 0;
}